--
-- Uwe R. Zimmer
-- Australia 2012
--

module Transitions.For_List_2D (
   transition_world -- :: List_2D Cell -> List_2D Cell
) where

--import Data.Cell (Cell)
import Data.Cell (Cell (Head, Tail, Conductor, Empty))
import Data.Coordinates (Coord, Element_w_Coord)
import Data.List_2D
import Data.Integer_Subtypes (Nat)
import Transitions.RadixTrie


-- First attempt - O(n) as it goes through the list from start to finish,
-- and O(n) again as it calls functions that are O(n)
-- so this function is O(n squared)
-- yuck!
transition_world :: List_2D Cell -> List_2D Cell
transition_world world = transition_world_recurser world (create_neighbours world)
   
-- Takes the current state of the world, and the neighbourhood Radix Trie,
-- and advances to the next state.
transition_world_recurser :: List_2D Cell -> FirstRadixNode (Maybe (FirstRadixNode (Maybe Nat))) -> List_2D Cell
transition_world_recurser world neighbours = case world of
   (e, (x, y)) : es
      | (new_cell_state == Empty)   -> transition_world_recurser es neighbours
      | otherwise                   -> (new_cell_state, (x, y)) : transition_world_recurser es neighbours
      where new_cell_state = compute_new_cell_state (e, (x, y)) neighbours
   []                               -> []
   
-- this one was shit easy
compute_new_cell_state :: Element_w_Coord Cell -> FirstRadixNode (Maybe (FirstRadixNode (Maybe Nat))) -> Cell
compute_new_cell_state (e, (x, y)) neighbours = case e of
   Head                 -> Tail
   Tail                 -> Conductor
   Empty                -> Empty
   Conductor            -> case num_heads of
         Just 1      -> Head
         Just 2      -> Head
         _           -> Conductor
         where num_heads = retrieve_coordinates (x, y) neighbours
            
-- construct a RadixTrie of coordinate/elem pairs that neighbour a Head
-- the elem in this case is a Nat that represents the number of Heads
-- that neighbour this cell
create_neighbours :: List_2D Cell -> FirstRadixNode (Maybe (FirstRadixNode (Maybe Nat)))
create_neighbours world = create_radix (get_heads world) (FirstRadixNode NullNode NullNode)
      

-- get the heads
get_heads :: List_2D Cell -> List_2D Cell
get_heads list = case list of
   []                      -> []
   (e, (x, y)): es         -> case e of
      Head                 -> (e, (x, y)) : get_heads es
      _                    -> get_heads es
      
      
-- create the Radix Trie using a list of Head-only elements. Hopefully this will kill off the memory issues
create_radix :: List_2D Cell -> FirstRadixNode (Maybe (FirstRadixNode (Maybe Nat))) -> FirstRadixNode (Maybe (FirstRadixNode (Maybe Nat)))
create_radix heads working = case heads of
   []                      -> working
   (_, (x, y)): es         -> create_radix es (insert_neighbour (x, y) working)
      
      
-- insert a head into the neighbours data set
insert_neighbour :: Coord -> FirstRadixNode (Maybe (FirstRadixNode (Maybe Nat))) -> FirstRadixNode (Maybe (FirstRadixNode (Maybe Nat)))
insert_neighbour (x, y) neighbours = insert_recurser neighbour_set neighbours
   where neighbour_set = [(a, b) | a <- [x-1..x+1], b <- [y-1..y+1], (a /= x || b /= y)]


-- this function will go through the list of neighbours generated by the list
-- comprehension above and add or insert 1 to every coordinate location
insert_recurser :: [Coord] -> FirstRadixNode (Maybe (FirstRadixNode (Maybe Nat))) -> FirstRadixNode (Maybe (FirstRadixNode (Maybe Nat)))
insert_recurser coords neighbours = case coords of
   []          -> neighbours
   c : cs      -> insert_recurser cs (increment_coordinates c neighbours)
      


